<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FirestoreUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">s0</a> &gt; <a href="index.source.html" class="el_package">edu.brown.cs.student.storage</a> &gt; <span class="el_source">FirestoreUtil.java</span></div><h1>FirestoreUtil.java</h1><pre class="source lang-java linenums">package edu.brown.cs.student.storage;

import com.google.api.core.ApiFuture;
import com.google.auth.oauth2.GoogleCredentials;
import com.google.cloud.firestore.AggregateQuerySnapshot;
import com.google.cloud.firestore.DocumentReference;
import com.google.cloud.firestore.DocumentSnapshot;
import com.google.cloud.firestore.Firestore;
import com.google.cloud.firestore.Query;
import com.google.cloud.firestore.Query.Direction;
import com.google.cloud.firestore.QueryDocumentSnapshot;
import com.google.cloud.firestore.QuerySnapshot;
import com.google.cloud.firestore.SetOptions;
import com.google.cloud.firestore.WriteResult;
import com.google.firebase.FirebaseApp;
import com.google.firebase.FirebaseOptions;
import com.google.firebase.cloud.FirestoreClient;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.ExecutionException;
import java.util.stream.IntStream;

/** Utility Class for interacting with Firebase Firestore */
public class FirestoreUtil implements IStorage {

  private Firestore db;
<span class="nc" id="L32">  private final String firebaseConfigPath = &quot;src/main/resources/firebase_config.json&quot;;</span>

<span class="nc" id="L34">  public FirestoreUtil() throws IOException {</span>
    try {
<span class="nc bnc" id="L36" title="All 2 branches missed.">      if (FirebaseApp.getApps().isEmpty()) {</span>
        // Input stream creation
<span class="nc" id="L38">        InputStream serviceAccount = new FileInputStream(this.firebaseConfigPath);</span>

        // More detailed credential loading
<span class="nc" id="L41">        GoogleCredentials credentials = GoogleCredentials.fromStream(serviceAccount);</span>
<span class="nc" id="L42">        FirebaseOptions options = FirebaseOptions.builder().setCredentials(credentials).build();</span>

        // initialize firebase and get firestore
<span class="nc" id="L45">        FirebaseApp.initializeApp(options);</span>
<span class="nc" id="L46">        this.db = FirestoreClient.getFirestore();</span>
<span class="nc" id="L47">        System.out.println(&quot;Firestore successfully set up.&quot;);</span>
      }

<span class="nc" id="L50">    } catch (IOException e) {</span>
<span class="nc" id="L51">      System.err.println(&quot;Firebase Initialization Error:&quot;);</span>
<span class="nc" id="L52">      e.printStackTrace();</span>
<span class="nc" id="L53">      throw e; // Re-throw to maintain original method signature</span>
    }
<span class="nc" id="L55">  }</span>

  // adds a document or OVERWRITES it if it already exists
  @Override
  public void addDocument(String collection_id, String doc_id, Map&lt;String, Object&gt; data)
      throws IllegalArgumentException, ExecutionException, InterruptedException {
<span class="nc bnc" id="L61" title="All 6 branches missed.">    if (collection_id == null || doc_id == null || data == null) {</span>
<span class="nc" id="L62">      throw new IllegalArgumentException(</span>
<span class="nc" id="L63">          &quot;addDocument: collection_id, doc_id, or data cannot be null&quot;);</span>
    }
<span class="nc" id="L65">    DocumentReference docRef = this.db.collection(collection_id).document(doc_id);</span>
<span class="nc" id="L66">    ApiFuture&lt;WriteResult&gt; future = docRef.set(data);</span>
<span class="nc" id="L67">    System.out.println(&quot;Update time : &quot; + future.get().getUpdateTime());</span>
<span class="nc" id="L68">  }</span>

  // Differs from adding a document because it ADDS to the existing documents, and only overwrites
  // specified fields
  @Override
  public void updateDocument(String collection_id, String doc_id, Map&lt;String, Object&gt; data)
      throws IllegalArgumentException {
<span class="nc bnc" id="L75" title="All 6 branches missed.">    if (collection_id == null || doc_id == null || data == null) {</span>
<span class="nc" id="L76">      throw new IllegalArgumentException(</span>
<span class="nc" id="L77">          &quot;updateDocument: collection_id, doc_id, or data cannot be null&quot;);</span>
    }
<span class="nc" id="L79">    DocumentReference docRef = this.db.collection(collection_id).document(doc_id);</span>
<span class="nc" id="L80">    docRef.set(data, SetOptions.merge());</span>
<span class="nc" id="L81">  }</span>

  @Override
  public Map&lt;String, Object&gt; getDocument(String collection_id, String doc_id)
      throws InterruptedException, ExecutionException {
<span class="nc" id="L86">    DocumentReference docRef = this.db.collection(collection_id).document(doc_id);</span>
    // asynchronously retrieve the document
<span class="nc" id="L88">    ApiFuture&lt;DocumentSnapshot&gt; future = docRef.get();</span>
    // future.get() blocks on response
<span class="nc" id="L90">    DocumentSnapshot document = future.get();</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">    if (document.exists()) {</span>
<span class="nc" id="L92">      return document.getData();</span>
    } else {
<span class="nc" id="L94">      System.out.println(&quot;No such document: &quot; + doc_id + &quot; in collection &quot; + collection_id);</span>
    }
<span class="nc" id="L96">    return null;</span>
  }

  @Override
  public void deleteDocument(String collectionID, String docID)
      throws InterruptedException, ExecutionException {
<span class="nc bnc" id="L102" title="All 2 branches missed.">    if (docID == null) {</span>
<span class="nc" id="L103">      throw new IllegalArgumentException(&quot;deleteDocument: docID cannot be null&quot;);</span>
    }
<span class="nc bnc" id="L105" title="All 2 branches missed.">    if (collectionID == null) {</span>
<span class="nc" id="L106">      throw new IllegalArgumentException(&quot;deleteDocument: collectionID cannot be null&quot;);</span>
    }
<span class="nc" id="L108">    DocumentReference document = this.db.collection(collectionID).document(docID);</span>
<span class="nc" id="L109">    ApiFuture&lt;WriteResult&gt; deleteFuture = document.delete(); // Firestore returns a future</span>
<span class="nc" id="L110">    WriteResult result = deleteFuture.get(); // Wait for the operation to complete</span>
<span class="nc" id="L111">    System.out.println(&quot;Document deleted at: &quot; + result.getUpdateTime());</span>
<span class="nc" id="L112">  }</span>

  @Override
  public List&lt;Map&lt;String, Object&gt;&gt; getCollection(String collectionID)
      throws ExecutionException, InterruptedException {
<span class="nc bnc" id="L117" title="All 2 branches missed.">    if (collectionID == null) {</span>
<span class="nc" id="L118">      throw new IllegalArgumentException(&quot;getCollection: collectionId cannot be null&quot;);</span>
    }
    // asynchronously retrieve all documents
<span class="nc" id="L121">    ApiFuture&lt;QuerySnapshot&gt; future = this.db.collection(collectionID).get();</span>
    // future.get() blocks on response
<span class="nc" id="L123">    List&lt;QueryDocumentSnapshot&gt; documents = future.get().getDocuments();</span>
<span class="nc" id="L124">    List&lt;Map&lt;String, Object&gt;&gt; collection = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">    for (QueryDocumentSnapshot document : documents) {</span>
<span class="nc" id="L126">      collection.add(document.getData());</span>
    }
<span class="nc" id="L128">    return collection; // note this could return null I think</span>
  }

  @Override
  public long getDocumentCount(String collectionID)
      throws InterruptedException, ExecutionException {
    // Create an aggregation query
<span class="nc" id="L135">    ApiFuture&lt;AggregateQuerySnapshot&gt; future = this.db.collection(collectionID).count().get();</span>
    // Get the count
<span class="nc" id="L137">    AggregateQuerySnapshot snapshot = future.get();</span>
<span class="nc" id="L138">    return snapshot.getCount();</span>
  }

  @Override
  public List&lt;Map&lt;String, Object&gt;&gt; getProblems(String difficulty, int number)
      throws InterruptedException, ExecutionException, IOException {

    // Reference to the collection and create a query
<span class="nc" id="L146">    Query query = db.collection(&quot;Problems&quot;).whereEqualTo(&quot;difficulty&quot;, difficulty);</span>
    // Execute the query
<span class="nc" id="L148">    ApiFuture&lt;QuerySnapshot&gt; querySnapshot = query.get();</span>
    // Get the query results
<span class="nc" id="L150">    List&lt;QueryDocumentSnapshot&gt; documents = querySnapshot.get().getDocuments();</span>

<span class="nc" id="L152">    List&lt;Map&lt;String, Object&gt;&gt; selectedProblems = new ArrayList&lt;&gt;();</span>
    // get the size of the document
<span class="nc" id="L154">    int docSize = documents.size();</span>
    // if no question of this difficulty found at all,
<span class="nc bnc" id="L156" title="All 2 branches missed.">    if (docSize == 0) {</span>
<span class="nc" id="L157">      return new ArrayList&lt;&gt;();</span>
    }
    // return all that we have if not enough questions of this difficulty level.
<span class="nc bnc" id="L160" title="All 2 branches missed.">    number = docSize &lt; number ? docSize : number;</span>

<span class="nc" id="L162">    IntStream randomInts = new Random().ints(number, 0, docSize);</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">    for (int num : randomInts.toArray()) {</span>
      // get document and convert it to string and then deserialize it
<span class="nc" id="L165">      Map&lt;String, Object&gt; doc = documents.get(num).getData();</span>
<span class="nc" id="L166">      selectedProblems.add(doc);</span>
    }
<span class="nc" id="L168">    return selectedProblems;</span>
  }

  @Override
  public Map&lt;String, Object&gt; getProblem(String problemID)
      throws InterruptedException, ExecutionException, IOException {
<span class="nc" id="L174">    Query query = db.collection(&quot;Problems&quot;).whereEqualTo(&quot;problemID&quot;, problemID);</span>
<span class="nc" id="L175">    ApiFuture&lt;QuerySnapshot&gt; querySnapshot = query.get();</span>
<span class="nc" id="L176">    List&lt;QueryDocumentSnapshot&gt; documents = querySnapshot.get().getDocuments();</span>
<span class="nc" id="L177">    return documents.get(0).getData();</span>
  }

  @Override
  public List&lt;Map&lt;String, Object&gt;&gt; sortCollection(String collectionID, String field)
      throws InterruptedException, ExecutionException, IOException {
<span class="nc bnc" id="L183" title="All 2 branches missed.">    if (field == null) {</span>
<span class="nc" id="L184">      throw new IllegalArgumentException(&quot;sortCollection: field cannot be null&quot;);</span>
    }
<span class="nc bnc" id="L186" title="All 2 branches missed.">    if (collectionID == null) {</span>
<span class="nc" id="L187">      throw new IllegalArgumentException(&quot;collectionID: collectionID cannot be null&quot;);</span>
    }
<span class="nc" id="L189">    Query query = db.collection(collectionID).orderBy(field, Direction.DESCENDING);</span>
<span class="nc" id="L190">    List&lt;QueryDocumentSnapshot&gt; documents = query.get().get().getDocuments();</span>
<span class="nc" id="L191">    List&lt;Map&lt;String, Object&gt;&gt; resultList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">    for (QueryDocumentSnapshot document : documents) {</span>
<span class="nc" id="L193">      resultList.add(document.getData());</span>
    }
<span class="nc" id="L195">    return resultList;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>